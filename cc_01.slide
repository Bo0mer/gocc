Go@Chaos Camp
14.12.2022

* Днес

- Структура на програмата, типове, цикли, функции, масиви

* Връщаме се обратно към Hello, world! примера:

.play code/intro/hello_world.go

и се фокусираме върху

    package main


* Пакети

Една програма на `Go` е структура от пакети. Нямате шанс просто да хвърлите
едно парче код в даден файл и то да тръгне.

- Ако идвате от Python си мислете за модули.
- Ако идвате от Java се чувствайте като у дома си


* Особености

- Всеки файл принадлежи на точно един пакет
- `n` файла могат да са в един пакет (демек `filename` != `package`)
- Стандартната библиотека е съставена от пакети като `fmt`, `os`...
- Всяка директория съдържа точно един пакет
- Очевидно, дадени пакети могат да използват други

Без значение от колко файла се състои:

- всеки пакет се компилира като една самостоятелна единица
- всичко, дефинирано в пакета, има видимимост във всички негови файлове


* One package to rule them all

В една програма имаме точно един пакет `main` и при изпълнението ѝ се изпълнява функцията `main` в него.

Програмата приключва, когато приключи изпълнението на функцията `main`.

Тя *не* връща нищо.

.play code/intro/main.go

* Преизползване на пакети

Става с ключовата думичка `import`, последвана от името на пакета, в кавички

    import "fmt"

Ако искаме да импортнем няколко пакета:

    import "fmt"
    import "os"

което go fmt би свел до

    import (
        "fmt"
        "os"
    )

имаме и такива магии:

    import "github.com/keltia/leftpad"

_wow!_much_import!_how_to_dependency?_

* import

- По време на компилация се компилират първо импортнатите пакети
- Всеки пакет се компилира *точно* един път
- Ако един пакет се промени и прекомпилира, всички пакети, които го импортват, трябва да бъдат прекомпилирани
- Импортнат пакет, който не се използва, води до грешка по време на компилация

.play code/intro/hello_world_with_useless_import.go


* Видимост

Какво точно можем да използваме от импортнат пакет? Тук става забавно.

_Даден_идентификатор_(било_то_на_променлива,_константа,_тип,_функция_или_
_метод)_е_видим_извън_пакета_си,_тогава_и_само_тогава_когато_името_му_започва_с_главна_буква._

Наричаме ги `exported` (на други места им викат `public`).

Останалите са недостъпни (демек `private`)

    // Accessible outside of the package.
    var TheAnswer = -42

    // Not accessible outside of the package.
    var theRealAnser = 42

* Основни типове
- bool
- uint, int
- float32, float64
- complex64, complex128
- string
- array
- struct
- channel


* ... но това не е всичко

* Независещи от архитектурата числови типове

Имаме свободата да решим точно колко байта да е нашия тип:

- int8
- int16
- int32 (познат също като rune)
- int64

\... и разбира се имаме `unsigned`:

- uint8 (познат също като byte)
- uint16
- uint32
- uint64

* Зависещи от архитектурата

- `uint` и `int` може да са 32 или 64 бита
- `uintptr` - нещо достатъчно голямо за да съдържа битовете на указател

*Пояснение*: типовете `int` и `int32` са различни дори в архитектури на които `int` е 32 бита. Същото важи и за `uint` и `uint32`.


* Пример

    var name string = "Лили Иванова"
    var age uint8 = 25

Горното можем (и трябва) да запишем като:

    var (
        name string = "Лили Иванова"
        age uint8 = 25
    )

Ако са с един и същи тип, можем и така:

     var name, age string = "Лили Иванова", "двадесет и пет"

_WTF!_WTF!_WTF!_ Защо типът е на грешното място!?

* type-inference

Можем да правим и така:

    name := "Лили Иванова"
    age := 25

- Сам се усеща какъв тип да сложи на променливата
- Това *НЕ* може да се ползва в глобалния скоуп

.play code/intro/wrong_type_inference.go


* Кастване

Кастването работи, както очаквате:

    number := 42                      // (int=42)
    specificNumber := float64(number) // (float64=42.0)

С тази разлика, че нямате имплицитен каст:

.play code/intro/implicit_cast_error.go

* Strings and runes

- Имаме вградени memory-safe UTF-8 strings
- Един unicode code point се нарича `rune` и се инициализира с единични кавички: `'a',`'ж',`'本',`'\u12e4'`
- String може да се инициализира с двойни кавички или с backticks за literals

.play code/intro/strings_and_runes.go



* Стойности по подразбиране

Не се грижим за това да си инициализираме стойностите. Всяка променлива в Go се инициализира по подразбиране:

    var (
        digit int         // 0
        digit *int        // nil
        number float64    // 0.0
        isIt bool         // false
        name string       // ""
        root complex64    // (0+0i)
        pipe chan <type>  // nil
    )


* Инициализация

- Във всеки пакет може еднократно да се инициализират неща
- Това става с помощта на `init()` функции

.play code/intro/init.go

За разлика от нормалните функции, за които ще си говорим следващия път, можем да имаме няколко `init()` функции в един пакет


* Unused variable

Дефинирана стойност, която не се използва, води до грешка по време на компилация

.play code/intro/unused_var.go

* Константи

Аналогично с var:

    const (
        name string = "Лили Иванова"
        age uint8 = 25
    )

Могат да бъдат само

- bool
- int, int8, int16, int32, int64
- uint, uint8, uint16, uint32, uint64
- float32, float64
- complex64, complex128
- string


* iota

Нали помните `enum`?

    const (
        c0 = iota  // c0 == 0
        c1 = iota  // c1 == 1
        c2 = iota  // c2 == 2
    )

iota представлява последователни нетипизирани целочислени константи.

    const (
        Monday = iota
        Tuesday
        Wednesday
        Thursday
        Friday
        Partyday
        Sunday
    )

.link http://en.wikipedia.org/wiki/Iota _Wikipedia:_ Iota is the ninth letter of the Greek alphabet.

* Малко по-сложен пример

.play code/intro/iota.go


* Контролни структури


* if

    if age < 13 {
        fmt.Print("Още не си тийнейджър")
    } else if age >= 13 && age < 20 {
        fmt.Print("В момента си тийнейджър")
    } else {
        fmt.Print("Минали са ти тийнейджърските години")
    }

- Няма `(` и `)` около условията
- Отварящата `{` е на същия ред с условието.
- `}`else`{`  трябва да са на един ред
- Ползва се `else`if`, няма `elseif`

* for

Добрия стар `for` от C:

    for i := 0; i < 20; i++ {
        fmt.Println(i)
    }

И точно както в C, някои от аргументите не са задължителни.
\... *някои* да се чете като *всички*.

.play code/intro/endless_for.go /^\s+for {/,/}/

_Забележка:_ Отварящата `{` и тук е на същия ред с условието


* while

Няма. `for` покрива всичките му приложения.


* foreach

Няма. `for` покрива всичките му приложения.


* switch

    switch {
    case age < 13:
        fmt.Print("Още не си тийнейджър")
    case age >= 13 && age < 20:
        fmt.Print("В момента си тийнейджър")
    default:
        fmt.Print("Минали са ти тийнейджърските години")
    }

Няма нужда от излишния `break`

Ако искаме да изпълним два поредни `case-а`, използваме `fallthrough`.


* break и continue

Все пак има `break`, който е приложим за `for` цикли.

`continue` работи, точно както очаквате и където очаквате.


* goto

.image assets/exorcist.jpg

Да, има и такова.

Ако не знаете кога, не го ползвайте.

Към момента допускаме, че още не знаете кога => не го ползвате.


* Особености, с които се сблъскахте (Q&A)


* ;

*Q:* Няма точка и запетая след всеки израз?

*A:* Всъщност има, но е имплицитна.


* Индентация

*Q:* Интервали vs. Табове?
*A:* Един таб.


* Указатели

* Указатели
.image assets/armed.jpg

- Особен момент е, че нямаме аритметиката с указатели
- Ако знаете как да ги ползвате в C/C++, нямате ядове

* За останалите: Опреснителен курс

- Всички променливи, константи и функции се пазят в оперативната памет
- Всяка запазена стойност стои в отделна клетка
- Всяка клетка си има уникален адрес (0xb6802, 0xfx04001d7f0)
- За да вземем адреса на дадена променлива, използваме унарния оператор `&`
- Имаме тип указател: `*int`
- Указателите са с константна големина
- Указател може да сочи към указател
- В Go една стойност се изчиства от паметта, когато няма указатели към нея
- Не можем да имаме указатели към константи
- Очевидно `intP`==`*(&intP)`

* Пример

.play code/funcs_and_pointers/pointers.go

* Как да си направим дупка в крака?

.play code/funcs_and_pointers/broken_pointer.go

* Funcs 101

- Функциите са основна структурна единица в Go
- Всеки проблем, който някога ще решавате, ще е разбит на функции
- Една функция върши точно едно нещо
- ... в противен случай правите нещо грешно
- Може да връща няколко резултата
- Последните три точки не си противоречат взаимно
- Редът, в който са дефинирани, не е от значение
- Може и да изпада в паника (буквално)


* С ключовата дума func могат да се създават три неща

1. Функции

2. Ламбди

3. Методи


* Функции

.play code/funcs_and_pointers/simple_funcs.go

* Аргументи

    func foo(a int, b string) float64

Функцията foo приема int и string и връща float64

- Винаги работим върху копия от аргументите
- Ако това не ни устройва, подаваме указател
- Нямаме стойности по подразбиране (optional parameters) или overloading

Когато няколко аргумента са от един тип:

    func bar(a, b int, c float64) float64

* Произволен брой аргументи

    func sum(args ...int) int

Функцията sum приема произволен брой числа и връща техния сбор

.code code/funcs_and_pointers/lots_of_arguments.go /^func sum/,/^}/

Извикваме я с колкото ни трябват

    sum()           //0
    sum(2, 3)       //5
    sum(2, 3, 4, 5) //14

Трябва да е последния аргумент на функцията
* ще говорим по-подробно за `range`

* Множество стойности като резултат

.play code/funcs_and_pointers/many_results.go

* Защо?

- Няма нуждата от някои C идиоми, като ...
- ... модифициране на аргумент, подаден по адрес
- ... errno
- По-лесно справяне с грешки


* Как е реализирано в "стари" езици:

- C/C++ и компания: масив или структура
- Python: tuple-и

* Как е реализирано в Go?
- Много просто: връщате каквото ви трябва

* Ами ако не ни трябват всичките резултати?

1. Знаем, че ако дефинираме променлива и не я използваме, гърми
2. Ако искаме онзи сбор и не ни интересува броят аргументи, това ще изгърми

    result, count := sumAndCount(2, 3, 4, 5)

3. Ако нямаме нужда от дадена стойност, я присвояваме на _:

    result, _ := sumAndCount(2, 3, 4, 5)

- Тя не се запазва и не можем да я достъпим след това
- По-полезно е, отколкото ви се струва


* Именовани резултати

.code code/funcs_and_pointers/named_sum_and_count.go /^func sum/,/^}/

- Резултатите се инициализират преди изпълнението на функцията
- Добра идея са за да документираме какво означават върнатите стойности
- Няма нужда да ги указваме при return
- Въпреки това е добре да го правим

* Фунцкиите като стойности

- В реда на нещата е функция да приема функция

.code code/funcs_and_pointers/as_values.go /^func foo/,/^}/

- Няма нищо лошо в това и да връщаме функция

.code code/funcs_and_pointers/as_values.go /^func createRandomGenerator/,/^}/

- Въобще, можем да ги присвояваме на стойност
- Но можем да ги сравняваме само с `nil`

* ...или да изпълни себе си
.play code/funcs_and_pointers/factorial.go /^func factorial/,/^}/


* Именоване на функции

- Кратки, описателни имена
- Започва с буква, последвана от букви, цифри или _
- Помните ли, че тук всеки стринг е UTF-8?
- `ЗнаетеЛиЧеHelloWorldНаКитайскиЕ世界` е валидно име на функция
- *НЕ* пишете такива имена!
- camelCase
- camelCase, не snake_case
- Ако функцията ни трябва извън текущия пакет: CamelCase


* Анонимни функции

  func(x, y int) int { return x * y }

- НЕ можем да дефинираме нормална функция в тялото на друга.
- Но пък можем да създаваме ламбди
- Ламбдите си нямат име... очевидно
- Удобни са за дребни неща

.play code/funcs_and_pointers/lambdas.go /^func main/,/^}/

* Scope, visibility & escape analysis

.play code/funcs_and_pointers/visibility.go

Променливата `count` нужна ли е въобще?

* defer

- `defer` е специален механизъм на езика
- `defer` добавя *извикване* на функция в един списък (стек)
- Когато обграждащата функция приключи, тези извиквания се изпълняват в обратен ред

.play code/funcs_and_pointers/defer_example_0.go /^func main/,/^}/

* Пример:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }

        written, err = io.Copy(dst, src)
        dst.Close()
        src.Close()
        return
    }

Какви са проблемите с този код?


* По-красивият, правилен и работещ начин е това:

    func CopyFile(dstName, srcName string) (written int64, err error) {
        src, err := os.Open(srcName)
        if err != nil {
            return
        }
        defer src.Close()

        dst, err := os.Create(dstName)
        if err != nil {
            return
        }
        defer dst.Close()

        return io.Copy(dst, src)
    }

`defer` се използва за сигурно и лесно почистване на ресурси (отворени файлове, заключени `mutex-и`, etc.)

* Доуточнения

- `defer` statement-ите ни позволяват да мислим за затварянето на файловете веднага след отварянето им
- Това ни гарантира, че няма да забравим в никой случай за затварянето им, независимо кой, кога и как променя кода след нас

* Три прости правила за defer (1)

- Аргументите на `defer` се оценяват, когато самият `defer` statement се оценява

    func a() {
        i := 0
        defer fmt.Println(i)
        i++
        return
    }

- Това принтира "0"

* Три прости правила за defer (2)

- Функциите се изпълняват в `LIFO` ред

    func b() {
        for i := 0; i < 4; i++ {
            defer fmt.Print(i)
        }
    }

- Това изписва "3210"

* Три прости правила за defer (3)

- `defer` -натите функции могат да "пипат" по именованите връщани аргументи на обграждащата функция

    func c() (i int) {
        defer func() { i++ }()
        return 1
    }

- Тази функция връща "2"
- Това е удобно, за да променяме връщаните стойности от функции, примерно за да върнем грешка

* Примери

.play code/funcs_and_pointers/defer_example1.go /^func deferExample/,/^}/

-

.play code/funcs_and_pointers/defer_example2.go /^func deferExample/,/^}/

* Методи

За тях ще си говорим като стигнем до дефиниране на типове

* Структури от данни

* Arrays

- По нашенски: масиви
- Последователност от еднакви по тип елементи
- С конкретна фиксирана дължина

.play code/data_structures/array.go /^func main()/,/^}/

Очевидно броим от 0


* Инициализация

    var x [5]string
    x[0] = "Баба"
    x[1] = "меца"
    x[2] = "яде"
    x[3] = "от"
    x[4] = "медеца"

или накратко:

    x := [6]float64{98, 93, 77, 82, 83}

Чакай малко! Подали сме само 5 числа.

    x[5] == 0


* Компилаторите могат да броят!

- ??!?

    x := [...]string{"Incredible", "isn't", "it?"}

- В този случай `x` е от тип `[3]string`

* Сравняване на масиви

Да разгледаме следния код

.play code/data_structures/array_comparison.go /dqdo/,/fmt/


* Големината на масив е част от типа му

.play code/data_structures/array_comparison_error.go /dqdo/,/fmt/


* Черва на масивите

- Те са стойности, копират се, а не се предават по референция

    func (foo [100]uint32)

- Дори, когато правим

    a := [100]float64
    b := a

- Може да се избегне с указател към масив

    func (foo *[100]uint32)

- Няма нужда да го ползвате, ще видите защо другия път

* Полезнотии

- `len()` - връща размера като int
- `range` - ключова дума, която позволява да итерираме по индекс и стойност

    for index, value := range arr {
        ...
    }



    for index := 0; index < len(arr); index++ {
        value := arr[index]
        ...
    }

Тези два цикъла са еквивалентни

_(Заради_range_нямаме_нужда_от_foreach)_

* Това е много готино, но...

- Не могат да растат
- Или да се свиват
- Спомняте ли указателя към масив? А ако искаме да подадем масив с друга дължина?
- Какво е това!? Живеем в 2021, не може ли да се направи нещо?


* Slices

За тях следващия път.

* Следващия път

- Slice-ове, map-ове
- Типове и интерфейси
