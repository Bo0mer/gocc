Concurrency
11.01.2023

* Но преди това...

* Въпрос #1

Какво е интерфейс и как се създава?

* Въпрос #1

Какво е интерфейс и как се създава?

- Тип от езика
- Съвкупност от дефиниции на методи

    type Stringer interface {
        String() string
    }

* Въпрос #2

По какъв начин показваме, че тип имплементира интерфейс?

* Въпрос #2

По какъв начин показваме, че тип имплементира интерфейс?

- Никак
- Типовете имплементират интерфейси неявно

* Какво ще говорим днес?

- Конкурентност с/у Паралелизъм
- go рутини
- Споделяне чрез комуникация
- channels

* Що е то конкурентност?

* Магически паралелизъм?

- Go е конкурентен
- ... следователно всичко ще работи паралелно! Yey!
- Не е точно така.

* Конкурентност с/у Паралелизъм

.image assets/cvsp_coke.png _ 600

* Конкурентност

- Конкурентност е да се *занимаваш* с много неща "едновременно"
- Имаме набор от независими процеси/задачи
- Могат да започват, работят и приключват в припокриващи се периоди
- Програмите в една операционна система, работеща на 1 процесорно ядро, са конкурентни
- В JavaScript има concurrency, без да е необходим паралелизъм

* Паралелизъм

- *Изпълнение* на различни неща едновременно
- Едновременно пресмятане на една задача от няколко процеса

* Конкурентност с/у Паралелизъм

- Когато говорим за конкурентност става въпрос за структурата на програмата
- Когато говорим за паралелизъм става въпрос за изпълнението ѝ

* Обяснение с малко повече gophers

- Лекция на Rob Pike по въпроса:

.link http://blog.golang.org/concurrency-is-not-parallelism

.link https://talks.golang.org/2012/waza.slide

* IO-bound vs. CPU-bound

- CPU-bound са програми, които главно зависят от време, прекарано в процесора
- IO-bound са програми, които главно зависят от време, прекарано в чакане на мрежата, паметта или диска


* Подходи за конкурентност

- Процеси
- Нишки (native & green)
- Актьори
- Мега умни компилатори?

А как синхронизираме различните задачи?


* В C ползват вилици

.code code/concurrency101/c_fork.c

- `fork` създава ново копие на програмата, която изпълняваме
- Всички ресурси и променливи запазват стойността си в процеса-дете
- След създаването на новия процес, всички промени са локални
- Все едно клонираме хора, за да вършим повече работа едновременно


* Синхронизация на вилици

.code code/concurrency101/c_fork_sync.c

- `execl` спира изпълнението на текущия процес и зарежда друг
- `waitpid` позволява на родителя да чака свършването на конкретно дете

* Предимства и недостатъци на fork

Против:

- Само за UNIX
- Създаването на нов процес е бавно и паметоемко
- Комуникацията между процеси е трудна - нямат обща памет
- Копира се памета на процеса

За:

- Копира се памета на процеса
- Стабилност
- Детето е независимо - ако омаже нещо, родителят няма да пострада


* В Go се правим на модерни

- Fork не се препоръчва
- Имаме по - добър начин, за него след малко
- Ако все пак искате чрез библиотеката `syscall` можете да вдигнете нов процес
- Не го правете, ако нямате много сериозна причина


* Нишки

- Много нишки живеят в един и същи процес
- Следователно имат достъп до една и съща памет
- Глобалните променливи са общи за нишките
- Създават се бързо и лесно
- Това е концепция в операционните системи
- Някои езици ги поддържат директно
- Други ги скриват зад ниво на абстрактност

* Нишки в C

.code code/concurrency101/c_threads.c /ticker/,

* Нишки в Python

.code code/concurrency101/python_threads.py /ticker/,/thread.start/

или

.code code/concurrency101/python_threads.py /class/,/thread.join/

* Goroutines


* Скучно

За да се съсредоточим върху това, което се опитваме да кажем ще дадем скучен пример.

.play code/concurrency101/boring.go /^func main/,

За конкурентноста таймингът е важен. Нека е малко по - непредвидим.


* Малко по - малко скучно

Ще сложим случайно време за сън.

.play code/concurrency101/less-boring.go /^func main/,

Скучната ни програма ще продължи да работи така до безкрайност. Като много скучна лекция, от която ви е неудобно да си тръгнете.


* Да я игнорираме

Скучната програма не заслужава вниманието ни, нека не я чакаме.

С `go` пускаме функция нормално, но пускащия няма нужда чака приключването й.

Пускаме goroutine.

.play code/concurrency101/go-less-boring.go /^func main/,

Когато main приключи програмата спира.


* Да я игнорираме малко по - малко

.play code/concurrency101/go-less-boring-sleep.go /^func main/,

Изпълнявахме main и скучната функция едновременно.

С края на main дойде и края на скучната функция.


* Какво е Goroutine

- Независимо изпълняваща се функция
- Практически безплатни са за създаване от към памет и процесорно време. Може да имате стотици хиляди в един процес
- Не е thread
- Зелени нишки
- Има умен scheduler, който мапва горутини към OS нишки
- Но ако мислите за тях като за много евтини нишки, няма да сте далеч от истината
- Дизайнът на езика и особено go рутините са много повлияни от Communicating sequential processes на C. A. R. Hoare

.link http://usingcsp.com/cspbook.pdf

* Вдъхновено от

- Последните няколко примера са безсрамно присвоени от лекция на Rob Pike. Интересна е!

.link http://www.youtube.com/watch?v=f6kdp27TYZs

- А сега да се върнем към нишки и goroutines


* Проблеми, свързани с нишки

От това, че имат една и съща памет, следва, че могат да достъпват едни и същи променливи

    int i = 0

    thread1 { i++ }
    thread2 { i++ }

    wait { thread1 } { thread2 }
    print i

Тук `i` накрая може да бъде 1 или 2.


* Критични секции

- Части от кода, които могат да бъдат изпълнени само от една нишка/процес в даден момент, се наричат критични секции
- Те са основна част от многозадачното програмиране
- Има много похвати за реализирането на критични секции
- STM, Semaphores & Co., Message passing, Actors

В Go имаме Semaphores и Message passing

* Communicate by sharing vs. Share by communicating

- Може експлицитно да използваме "ключалки", за да ограничаваме едновременния достъп до споделена памет
- В Go също може да го правим, подобно на повечето mainstream езици
- Но в много ситуации в Go би било по-добре да споделяме памет чрез комуникация
- Може да предаваме (референции към) данни между различни горутини с помощта на канали

* Channels

- Вграден тип, който се използва за комуникация между различни горутини
- Може да се използва и за синхронизация
- За тях има специален синтаксис


* Употреба на канали

- Инстанцират се с `make`, като се подава типа, който ще се пренася
- Този е за пренасяне на цели числа:

    intChannel := make(chan int)

- Могат да бъдат буферирани и небуферирани
- По подразбиране са небуферирани
- Ето буфериран канал за пренасяне на string slices:

    ch := make(chan []string, 100)

- В канал може да се изпраща и от него може да се получава

    ch <- 64
    read := <-ch

- Изпращането и получаването може да блокират докато някой "отсреща" не извърши "противоположната" операция


* IO в канал

Операциите по изпращане и получаване се изпълняват с оператора `<-`

- `chan`<-`someValue` изпраща по канала
- `someVar,`ok` = `<-chan` получава от канала

Simple demo:

.play code/concurrency101/channel-simple-demo.go /^func main/,

* Затваряне

Канал може да бъде затворен:

    close(ch)

- Повече не може да бъде отворен
- Писането в него води до паника
- Четенето в него никога не блокира
- Може да прочетете всички вече буферирани стойности, ако каналът е бил буфериран
- След това четенето връща нулевата стойност за предавания тип и false като втори резултат


* Каналите са първокласни обекти в Go

- По канал може да пренасяте канал

    c := make(chan chan int)

- Каналите могат да се подават като параметри на функции

  func doSomething(input chan string) {
    // do something
  }

- Функциите могат да връщат канали като резултат.

  func doSomethingElse() chan string {
    result := make(chan string)
    return result
  }

* range

Помните ли как ви казахме, че `range` е нещо супер яко?

- Може да чете и от канали
- Блокира, докато не получи следващата стойност
- Излизаме от `for`, когато каналът бъде затворен

  for val := range ch {
      fmt.Printf("Recieved: %#v\n", val)
  }


* Ограничени канали

- Каналите могат да бъдат само за четене (`<-chan`) или само за писане (`chan<-`)
- Това е по-полезно, отколкото звучи:

.play code/concurrency101/generator.go /func randomFeed/,


* Deadlock

.play code/concurrency101/deadlock.go /func main/,


* nil channel

- Писането в него блокира завинаги

    package main

    func main() {
        var c chan string
        c <- "ping" // deadlock
    }

- Четенето от него... блокира завинаги

    package main

    import "fmt"

    func main() {
        var c chan string
        fmt.Println(<-c) // deadlock
    }

* Пример за синхронизация

.play code/concurrency101/synchronization.go /func main/,

- Не използвайте int или bool ако просто използвате канала за синхронизация.
- Използвайте struct{} за целта - безплатно от гледна точка на памет.

* По-сложен пример

    var sem = make(chan struct{}, MaxOutstanding)

    func init() {
        for i := 0; i < MaxOutstanding; i++ {
            sem <- struct{}{}
        }
    }

    func handle(r *Request) {
        <-sem
        process(r)
        sem <- struct{}{}
    }

    func Serve(queue chan *Request) {
        for {
            req := <-queue
            go handle(req)
        }
    }


* Затваряне на канали

.play code/concurrency101/closing-channels.go

* Почивкa

* Да си спомним скуката

.play code/concurrency102/go-less-boring-sleep.go /^func main/,/^}/

- Грозен `time.Sleep`
- Ако искаме да гледаме скуката точно определен брой пъти?

* sync

[[https://golang.org/pkg/sync/][sync]] е пакет, който ни дава синхронизационни примитиви от сравнително ниско ниво:

- `Cond`
- `Mutex` и `RWMutex`
- `Once`
- `Pool`
- `WaitGroup`

един полезен интерфейс:

    type Locker interface {
        Lock()
        Unlock()
    }

и подпакет `atomic` с low-level memory примитиви

* WaitGroup

Изчаква колекция от горутини да приключат и чак тогава продължава с изпълнението.
Така не правим простотии със `time.Sleep`, както преди.

    type WaitGroup struct {}

    func (*WaitGroup) Add(delta int)
    func (*WaitGroup) Done()
    func (*WaitGroup) Wait()

* Пример

.play code/concurrency102/boring-with-sync.go /^func main/,/^}/

Стига вече с тая скука!

* По - интересен пример

.play code/concurrency102/waitgroup.go /^func main/,/^}/


* Mutex

    type Mutex struct {}

    func (*Mutex) Lock()
    func (*Mutex) Unlock()

- Дава достъп до даден ресурс само на една горутина по едно и също време
- Ако втора се опита да го достъпи, тя чака, докато ресурсът не бъде освободен
- Ако много горутини чакат за един ресурс, достъп се дава на една от тях на случаен принцип
- Има смисъл да се ползва като `private` атрибут на наш тип
- `Unlock()` е добра идея да бъде в `defer`
- Имплементира интерфейса `sync.Locker`

* В код

.play code/concurrency102/mutex.go /^func main/,/^}/

* На каналски

.play code/concurrency102/mutex_chan.go /^func main/,/^}/

* RWMutex

- Дава thread-safe достъп до споделен ресурс (променлива) от множество горутини
- Дава достъп до ресурса в даден момент само на *един* writer или на произволен брой readers
- По-ефективен от `Mutex` при ситуации, в които част от горутините само четат

    type RWMutex struct {}
    func (*RWMutex) Lock()
    func (*RWMutex) Unlock()
    func (*RWMutex) RLock()
    func (*RWMutex) RUnlock()
    func (*RWMutex) RLocker() sync.Locker

- Също имплементира `sync.Locker`
- Може да бъде "държана" от произволен брой "четци" или точно един "писар"
- `RLock` блоква само докато някой използва `Lock`
- Ако извикате някой unlock на незаключен mutex - run-time error
- `RLocker()` връща `Locker`, който ще използва `RLock` и `RUnlock` на оригинала

* Once

Обект от този тип ще изпълни точно една функция.

.play code/concurrency102/once.go /^func main/,/^}/

* select

* select

   select {
   case v1 := <-c1:
       fmt.Printf("received %v from c1\n", v1)
   case v2 := <-c2:
       fmt.Printf("received %v from c2\n", v2)
   case c3 <- 5:
       fmt.Println("send 5 to c3")
   default:
       fmt.Printf("no one was ready to communicate\n")
   }


Накратко: `switch` за канали.
Надълго: изчаква първия case, по който е изпратена или получена стойност

- Ако по никой от каналите няма "движение", изпълнява `default`
- Ако няма `default` блокира и изчаква
- Няма определен ред: ако няколко не-default case-а са възможни, избира се случаен
- Важна част от различни concurrency patterns в Go

* Въпрос

Какво би направил следния код?

.play code/concurrency102/indeterminate-select.go /^func main/,

Не се знае.

* 

.play code/concurrency102/select_rand.go /START/,/END/

* Concurrency patterns

* Timeout

.play code/concurrency102/timeout.go /^func fetch/,


* Игра на развален телефон

.image assets/gophereartrumpet.jpg

- или колко точно са бързи и евтини горутините?

* Игра на развален телефон

.play code/concurrency102/daisy-chain.go /START/,/END/


* Generators

.play code/concurrency102/fib.go


* Fan In

.play code/concurrency102/dummy_fanin.go /^func talk/,

- Какъв е проблемът тук?

* Fan In

.image assets/fanin.jpg

* Fan In <- Concurrency

.play code/concurrency102/select_fanin.go /func fanIn/,

* Finish channel

.code code/concurrency102/select_finish_fanin.go /FANIN START/,/FANIN END/

* Finish channel

.play code/concurrency102/select_finish_fanin.go /MAIN START/,/MAIN END/

* Words of wisdom

- Всичко това е забавно, но не ставайте човека с чука
- Го рутините и каналите са инструменти за построяване на програми
- Но понякога ви трябва просто брояч
- Инструменти за малките проблеми могат да бъдат намерени в "sync" и "sync/atomic"
- Често всички тези неща ще работят заедно, за да се справят с по - големите проблеми
- Използвайте правилния инструмент за задачата
